<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-21T17:27:26-07:00</updated><id>http://localhost:4000/</id><title type="html">Jared Rounsavall</title><subtitle>Sharing experience &amp; listening to criticism
</subtitle><entry><title type="html">Configuring AWS Codebuild for Github to Github Jobs</title><link href="http://localhost:4000/aws/2017/07/20/codebuild-for-g2g-jobs.html" rel="alternate" type="text/html" title="Configuring AWS Codebuild for Github to Github Jobs" /><published>2017-07-20T19:43:03-07:00</published><updated>2017-07-20T19:43:03-07:00</updated><id>http://localhost:4000/aws/2017/07/20/codebuild-for-g2g-jobs</id><content type="html" xml:base="http://localhost:4000/aws/2017/07/20/codebuild-for-g2g-jobs.html">&lt;p&gt;In our last chat we discovered a use-case for the development of a build process that will strip submodules out from one Github branch and post the resulting code to another, because our host can’t handle &lt;del&gt;the truth&lt;/del&gt; submodules in it’s workflow.&lt;/p&gt;

&lt;p&gt;If you haven’t guessed by the title of this article, today we’ll be walking through the configuration necessary to put CodeBuild in a place to handle Github to Github “deployments”.&lt;/p&gt;

&lt;p&gt;I’m assuming the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You have &lt;strong&gt;admin&lt;/strong&gt; access to an AWS Dashboard&lt;/li&gt;
  &lt;li&gt;Region is set to US West (Oregon) region&lt;/li&gt;
  &lt;li&gt;You own a Github Organization, or know someone who does.&lt;/li&gt;
  &lt;li&gt;On the Github Organization, you already have a Github repo with two branches. One that contains submodules, and another that will contain the “flattened” code&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;codebuild-baby-steps&quot;&gt;CodeBuild, baby steps&lt;/h2&gt;

&lt;p&gt;For those unfamiliar with AWS and its many available services, here’s a bit from the official AWS docs on CodeBuild:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS CodeBuild is a fully managed build service that compiles your source code, runs unit tests, and produces artifacts that are ready to deploy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sounds pretty great, right? Well it is.&lt;/p&gt;

&lt;p&gt;Leveraging Docker and a YAML file (buildspec.yml), it generates an environment where we can run all sorts of scripts &amp;amp; build tools to work with our code. you can think of it like your own build VM.&lt;/p&gt;

&lt;p&gt;For the purposes of this series we’ll slim down our approach, avoiding deployments, unit tests, and compiling. Instead we’ll focus on defining the necessary job within CodeBuild so that it can see the target repository and be in a place to execute steps that we’ll define later.&lt;/p&gt;

&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Let’s begin by visiting our AWS Dashboard and selecting the “Services” link in the top left corner of the screen. 
&lt;em&gt;Doing so should open up a screen that looks something like this:&lt;/em&gt;
&lt;img src=&quot;/assets/services-tab.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under Developer Tools select CodeBuild, or type CodeBuild into the search box and click the corresponding link.
&lt;em&gt;You should see the CodeBuild dashboard and be on the “Build projects” page.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select the “Create project” button.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;configuring-the-project&quot;&gt;Configuring the project&lt;/h3&gt;

&lt;p&gt;Now we’re greeted with a form where we’ll define the build at a high level. Project name, code source, the build environment, etc. Let’s tackle each of these one-by-one and explain their significance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/project-configuration.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Project name&lt;/strong&gt; - This is the name of your Build project, and will show up on the CodeBuild dashboard. It must contain between 2 &amp;amp; 255 characters with letters &amp;amp; numbers. No spaces! We are instead limited to “-“ and “_”.&lt;/p&gt;

&lt;p&gt;Let’s name it something pertinent and skip the description for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/project-name.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There we go! “rwdllc” is an abbreviation for my business, “g2g” for “Git to Git”, and “build” because that’s what we’re working on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Source provider&lt;/strong&gt; - This is where we define where our codebase lives. On Amazon S3, CodeCommit, or Github.&lt;/p&gt;

&lt;p&gt;Of course we’ll select “Github”, but notice that selecting the option expands the menu with “Repository” and “Repository URL”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/expanded-source-form.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Select “Use repository in my account” and follow the steps to give AWS access to your Public &amp;amp; Private repos.&lt;/p&gt;

&lt;p&gt;After that you should be able to select any repository that your account has access to. This includes repositories that may belong to an organization your account is under.&lt;/p&gt;

&lt;p&gt;-
&lt;strong&gt;Note&lt;/strong&gt;: if your organization’s repos are not showing up then you likely need to grant the OAuth application access to your org.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On Github, go to your profile and select “Settings”&lt;/li&gt;
  &lt;li&gt;Visit “Authorized OAuth Apps”&lt;/li&gt;
  &lt;li&gt;Click on the name of the OAuth application. In my case it was &lt;strong&gt;AWS CodeBuild US-WEST-2&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Under “Organization Access” Click “Grant” next to the desired organization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Environment: How to build&lt;/strong&gt; - Now we can tell AWS what sort of environment we’d like to build our project in by selecting a Docker image.&lt;/p&gt;

&lt;p&gt;“Environment Image” essentially lets you choose where you’ll source the Docker image from. That is to say that you can decide whether to use one provided by Amazon, or link to one you maintain on Amazon ECR or the Docker Cloud. We’ll select the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use an image managed by AWS CodeBuild&lt;/li&gt;
  &lt;li&gt;Operating System - Ubuntu&lt;/li&gt;
  &lt;li&gt;Runtime - Base&lt;/li&gt;
  &lt;li&gt;Version - aws/codebuild/ubuntu-base:14.04&lt;/li&gt;
  &lt;li&gt;Build Specification - Use the buildspec.yml in the source code root directory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More on the selections to follow, but for now your selections should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/environment-configuration.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, &lt;em&gt;what have we done?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;During the build, AWS is going to automatically spin up a basic Ubuntu environment defined by the Dockerfile here: https://github.com/aws/aws-codebuild-docker-images/tree/master/ubuntu/ubuntu-base/14.04&lt;/p&gt;

&lt;p&gt;We have also specified that process should use a YAML file in the root of our Github repo as a source for the build steps. Sit tight, we’ll define the contents of our &lt;strong&gt;buildspec.yml&lt;/strong&gt; file in another post!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Artifacts: Where to put the artifacts from this build project&lt;/strong&gt; - This is where we’d specify a location to store the files that result from the build process.&lt;/p&gt;

&lt;p&gt;Yes I’m well aware that our use-case doesn’t require any build artifacts, however at the time of this writing CodePipeline requires that we either have an artifact destination configured here or use CodeDeploy to deploy the resulting files. Since we are using CodePipeline to automate in a future post it’s a good idea to set this up now so that we don’t need to return.&lt;/p&gt;

&lt;p&gt;Select “Amazon S3”, give the artifact folder a meaningful name, and select an S3 bucket to hold the result.&lt;/p&gt;

&lt;p&gt;If you don’t have an S3 bucket available, please follow these steps to quickly create a dumping ground: http://docs.aws.amazon.com/AmazonS3/latest/gsg/CreatingABucket.html&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Service role&lt;/strong&gt; - As the tooltip states,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Specify a service role that enables AWS CodeBuild to call dependent AWS services on your behalf”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For the purposes of this demo, we’ll stick with the default selection and let CodeBuild make a new role for us.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/service-role.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ignore the advanced settings and proceed by selecting “Continue”, which will move you forward to the “Review” Step.&lt;/p&gt;

&lt;p&gt;Hit “Save” and bask in the glory that is your new build job.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/saved-build.png&quot; alt=&quot;services-tab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;are-we-done-yet&quot;&gt;Are we done yet?&lt;/h2&gt;

&lt;p&gt;No.&lt;/p&gt;

&lt;p&gt;You may notice that we haven’t actually done anything that has to do with the setup of an actual build PROCESS however we are now in a place where CodeBuild can see, and we can define a process in, our aforementioned buildspec.yml file.&lt;/p&gt;

&lt;p&gt;If you previously selected “Save and Build” then you may have noticed an error because we haven’t defined the buildspec file yet. Don’t panic! That’s the next topic we’ll cover, along with setting up EC2 parameter store.&lt;/p&gt;

&lt;p&gt;Stay tuned!&lt;/p&gt;</content><author><name></name></author><summary type="html">In our last chat we discovered a use-case for the development of a build process that will strip submodules out from one Github branch and post the resulting code to another, because our host can’t handle the truth submodules in it’s workflow.</summary></entry><entry><title type="html">AWS CodePipeline/Build from Github, to Github, with Love</title><link href="http://localhost:4000/use-case/2017/07/03/aws-codepipeline-github.html" rel="alternate" type="text/html" title="AWS CodePipeline/Build from Github, to Github, with Love" /><published>2017-07-03T19:43:03-07:00</published><updated>2017-07-03T19:43:03-07:00</updated><id>http://localhost:4000/use-case/2017/07/03/aws-codepipeline-github</id><content type="html" xml:base="http://localhost:4000/use-case/2017/07/03/aws-codepipeline-github.html">&lt;p&gt;Earlier this month I had the pleasure of setting up an automated build via AWS CodePipeline to take the contents of one Github repo’s branch and build it to another.&lt;/p&gt;

&lt;p&gt;Now, you might ask:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Jared, why on earth would you ever want to use CodePipeline to be so redundant?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, I’ll tell you.&lt;/p&gt;

&lt;h2 id=&quot;use-case-a-neat-host&quot;&gt;Use Case: A Neat Host&lt;/h2&gt;
&lt;p&gt;My current employer uses a platform called Pantheon for our web hosting. It’s a great service that offers just about everything you need in a development workflow. Essentialy it tries to simplify environment management by automatically providing version control, dev-&amp;gt;test-&amp;gt;live workflows, DB backups, etc..&lt;/p&gt;

&lt;p&gt;One of their Enterprise features alows you to set a Git upstream for use by all of the sites in your organization. That is to say that you could, for example, put together a repo on Github that contains a version of Drupal core along with any custom distributions that you may want to deploy across all of your organization’s sites! &lt;em&gt;Obviously, with a few hundred websites and the need to apply a standard of design and functionality across all of them, that’s exactly what we did.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;enter-git-submodules&quot;&gt;Enter Git Submodules.&lt;/h1&gt;

&lt;p&gt;For those of you who don’t know, submodules are &lt;del&gt;God’s gift to man&lt;/del&gt; a method by which a developer can reference other Github repositories from inside their own repository. Extremely useful when you want to build a fully-functioning upstream for your organization’s host ;)&lt;/p&gt;

&lt;p&gt;Well..&lt;/p&gt;

&lt;p&gt;At the time of this writing, Pantheon’s “upstream” feature does not allow for the use of submodules in the upstream. Wait a minute, if your organization has to build a custom Drupal upstream that sources code from 5 different repositories what are your options?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Brute force - Ignore submdules and manually add updated code from each repo to the new upstream whenever one of the several repositories are changed. Too cumbersome for me, especially when two of the source repos aren’t managed by my group!&lt;/li&gt;
  &lt;li&gt;Script it - Make a build script that replaces the submodules with a “flat” repo that sources the external code. This is better, but it still requires a manual step that goes beyond Git use. Adding more manual steps can be troublesome!&lt;/li&gt;
  &lt;li&gt;Automate - Use a service to trigger the script from #2 and push the result to your upstream! &lt;strong&gt;Bingo&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that you understand the use case here’s some primer for my solution!&lt;/p&gt;

&lt;h2 id=&quot;automating-with-amazon-web-services--co&quot;&gt;Automating with Amazon Web Services &amp;amp; co.&lt;/h2&gt;
&lt;p&gt;AWS is another &lt;del&gt;God’s gift to man&lt;/del&gt; one of those things that developers in the web-space should venture to grasp. They’ve got a host of services that can be used to solve most of your problem with a little know-how.&lt;/p&gt;

&lt;p&gt;Over the next few posts we’ll be using AWS CodePipeline, CodeBuild, IAM, Lambda, &amp;amp; EC2 Parameter Store to trigger a build on commit to a repo hosted on Github. The build will initialize all of the Git submodules(public &amp;amp; private), flatten the submodules to a single repository, and push everything to a master branch in the same repository for us to set as an upstream in our Pantheon organization.&lt;/p&gt;

&lt;p&gt;Stay tuned!&lt;/p&gt;</content><author><name></name></author><summary type="html">Earlier this month I had the pleasure of setting up an automated build via AWS CodePipeline to take the contents of one Github repo’s branch and build it to another.</summary></entry><entry><title type="html">Under Construction!</title><link href="http://localhost:4000/jekyll/update/2017/06/02/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Under Construction!" /><published>2017-06-02T19:43:10-07:00</published><updated>2017-06-02T19:43:10-07:00</updated><id>http://localhost:4000/jekyll/update/2017/06/02/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2017/06/02/welcome-to-jekyll.html">&lt;p&gt;This site is under construction&lt;/p&gt;</content><author><name></name></author><summary type="html">This site is under construction</summary></entry></feed>